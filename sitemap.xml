<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[用flask写图文直播网页（六）]]></title>
      <url>/2018/05/04/%E7%94%A8flask%E5%86%99%E5%9B%BE%E6%96%87%E7%9B%B4%E6%92%AD%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>图文直播</strong><br>大部分功能都做完了唉，剩下的就是把我们上传的图文美美的展示出来了开心ing..φ(&gt;ω&lt;*)<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>最后就只剩下直播首页了。</p>
<p>###首页布局<br>关于布局，这个就看个人喜好了，我是根据直播客这个平台的大小做的，定义的盒子大小也是跟直播客差不多。<br>test.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;
&lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt;
&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;100&quot;&gt;
&lt;!--&amp;lt;!&amp;ndash;禁用浏览器缓存&amp;ndash;&amp;gt;--&gt;

&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename = 'test/main.css') }}&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename = 'test/lrtk.css') }}&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename = 'css/test.css') }}&quot;&gt;
&lt;title&gt;直播的名字&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;main&quot;&gt;
    &lt;div class=&quot;zhibo&quot;&gt;
        &lt;div style=&quot;position: relative&quot;&gt;
                &lt;img src=&quot;{{ url_for('static', filename = 'images/11.png') }}&quot; height=&quot;200&quot; width=&quot;740&quot;&gt;
                &lt;div style=&quot;position: absolute; left: 10px; top: 50px&quot; id=&quot;title&quot;&gt;
                    &lt;h2&gt;介绍&lt;/h2&gt;
                &lt;/div&gt;
        &lt;/div&gt;
        &lt;div id=&quot;zhuti&quot;&gt;
            &lt;div id=&quot;zhiding&quot; class=&quot;time&quot;&gt;置顶&lt;/div&gt;
                &lt;article class=&quot;message&quot; id=&quot;firstMessage&quot;&gt;现场直播&lt;/article&gt;
        &lt;/div&gt;
        &lt;ul id=&quot;show&quot;&gt;
     {% for i in photo %}
             <li>
             <div class="patch">
               <div class="patch_on">
              <div class="time_info">
               <strong>{{ i.create_time }}</strong>
              </div>
             <div class="center">
           <img src="{{ url_for('static', filename = 'image/' + i.picture_path) }}" height="446" width="594" class="center_img">
            <p>{{ i.content }}</p>
            </div>
            </div>
             </div>
           </li>
           <p>{% endfor %}&lt;/p&gt;               


        &lt;/ul&gt;
        &lt;div class=&quot;qidai&quot;&gt;内容已经加载完毕，敬请期待更多内容&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{ url_for('static', filename = 
    'test/jquery.min.js') }}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{ url_for('static', filename = 'test/jquery.imgbox.pack.js') }}&quot;&gt;&lt;/script&gt;


&lt;script type=&quot;text/javascript&quot; src=&quot;{{ url_for('static', filename = 'test/test.js') }}&quot;&gt;&lt;/script&gt;

&lt;!--foot开始--&gt;
&lt;div id=&quot;foot&quot; &gt;
&lt;div&gt;
    &lt;a href=# rel=&quot;nofollow&quot;&gt;关于我们&lt;/a&gt;|&lt;a
     href=#&gt;实验室微博&lt;/a&gt;|&lt;a
     href=#&gt;实验室官网&lt;/a&gt;
    &lt;br/&gt;
    &quot;DROPS攻防实验室-安全研发小组版权所有&quot;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;

&lt;/script&gt;
&lt;/html&gt;
</p></code></pre><p>这里用到了一些前端的js文件，是一些同学帮我弄得，本来他给我写了一些json代码，无奈wo太笨了，json一时半会没学会，也就用了那种把图片信息存储进数据库的笨办法 o(TωT)o ，好了，下面再贴上直播主页的功能代码吧。</p>
<p>sc.py</p>
<pre><code># 直播首页
@app.route(&apos;/&apos;)
def test():
photo_all = Article.query.order_by(&apos;-create_time&apos;).all()
content = {
    &apos;photo&apos;: photo_all      # 获取所有数据
}
return render_template(&apos;test.html&apos;, **content)
</code></pre><p>到这里就没什么要说的了，代码也不详细一一解释了，我觉得，自己慢慢探索出代码的意义会更好。<br>总体看       哇！写的很少，代码很多，果然我还是好懒哦(ㅍ_ㅍ)</p>
</the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用flask写图文直播网页（四）]]></title>
      <url>/2018/05/04/%E7%94%A8flask%E5%86%99%E5%9B%BE%E6%96%87%E7%9B%B4%E6%92%AD%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>图文直播</strong><br>图文发布可是重中之重的啊，下面我们来一起实现图文发布的功能吧..(ノ￣▽￣)<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>前面已经实现了管理员的登录、登出和注销功能，下面来实现图片和文字的上传和图文管理。<br>实现之前，的先把前端页面主体部分的模型做出来</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-38ab64491eb926a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图文上传界面"><br>前端的一些样式可以自己随便做这里不贴代码了</p>
<p>###实现图文发布<br>首先的在static目录下建一个image文件夹把需要上传的图片存储在里面。然后获取图片的名字信息，和文字一起保存在数据库中。</p>
<p>sc.py</p>
<pre><code>#判断文件后缀名是否是图片类型文件
UPLOAD_FOLDER = &apos;./static/image&apos;
ALLOWED_EXTENSIONS = [&apos;png&apos;, &apos;jpg&apos;, &apos;jpeg&apos;, &apos;gif&apos;]
app = Flask(__name__)

#生成随机密钥
app.config[&apos;UPLOAD_FOLDER&apos;] = UPLOAD_FOLDER
app.config[&apos;SECRET_KEY&apos;] = os.urandom(24)
app.config.from_object(config)
db.init_app(app)

def allowed_file(filename):
    return &apos;.&apos; in filename and filename.rsplit(&apos;.&apos;, 1)[1] in ALLOWED_EXTENSIONS

# 发布图文
@app.route(&apos;/picture/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])
def upload_file():
admin_id = session.get(&apos;user_id&apos;)
if admin_id:
    if request.method == &apos;GET&apos;:
        return render_template(&apos;picture.html&apos;)
    else:
        file = request.files[&apos;file&apos;]
        content = request.form.get(&apos;content&apos;)
        if file:
            if allowed_file(file.filename):
                filename = secure_filename(file.filename)
                file.save(os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename))
            else:
                return u&apos;请按要求重新选择要上传的文件！&apos;
        else:
            pass
        photo1 = Article(content = content, picture_path = file.filename)
        db.session.add(photo1)
        db.session.commit()
        return redirect(url_for(&apos;index&apos;))
else:
    return redirect(url_for(&apos;login_a&apos;))
</code></pre><p>这上面的代码很大一部分来自于flask官方网站的图片上传部分，这是我自己添加了图文一起上传，只上传图片和只上传文字三个部分。</p>
</the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用flask写图文直播网页（五）]]></title>
      <url>/2018/05/04/%E7%94%A8flask%E5%86%99%E5%9B%BE%E6%96%87%E7%9B%B4%E6%92%AD%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>图文直播</strong><br>图文上传已经做好了，但是如果现在上传错误了咋办，这时候你就需要在后台做一个图文管理的界面了..<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>###实现图文管理功能<br>首先贴一下图文管理界面前端代码：<br>list-admin.html</p>
<pre><code>{% extends 'base.html' %}
{% block yemian %}图文管理界面{% endblock %}
    {% block main %}
    <div class="row">
        <form action="" enctype="multipart/form-data" method="POST" class="form-horizontal">
            <table class="table table-hover">
                <tr>
                    <th>序号</th>
                    <th>图片</th>
                    <th>文章</th>
                    <th>提交时间</th>
                    <th>操作</th>
                </tr>
                    {% for item in photo %}
                    <tr>
                        <td>{{ loop.index }}</td>
                        <td width="15%">
                            <img src="{{ url_for('static', filename = 'image/' + item.picture_path) }}" alt="" height="70" width="100">
                        </td>
                        <td width="50%" height="87">{{ item.content }}</td>
                        <td>{{ item.create_time }}</td>
                        <td>
                            <a href="{{ url_for('detail_a', photo_id = item.id) }}" class="btn btn-default btn-xs" title="查看"><i class="fa fa-search"></i></a>
                            <a href="{{ url_for('change_a', photo_id = item.id) }}" class="btn btn-default btn-xs" title="修改"><i class="fa fa-pencil"></i></a>
                            <a href="{{ url_for('remove', content=item.content) }}" class="btn btn-default btn-xs" title="删除"><i class="fa fa-trash"></i></a>
                        </td>
                    </tr>
                    {% endfor %}
            </table>
        </form>
    </div>
    {% endblock %}
</code></pre><p>####功能函数部分</p>
<pre><code># 图文管理
@app.route(&apos;/admin/list/&apos;, methods = [&apos;GET&apos;, &apos;POST&apos;])
def list_a():
admin2_id = session.get(&apos;user_id&apos;)
if admin2_id:
    if request.method == &apos;GET&apos;:
        data_all = Article.query.order_by(&apos;-create_time&apos;).all()
        items = {
            &apos;photo&apos;: data_all
        }
        return render_template(&apos;list-admin.html&apos;, **items)
else:
    return redirect(url_for(&apos;login_a&apos;))

# 删除图文
@app.route(&apos;/remove/&apos;)
def remove():
content = request.args.get(&apos;content&apos;)
photo1 = Article.query.filter(Article.content == content).first()
db.session.delete(photo1)
db.session.commit()
return redirect(url_for(&apos;list_a&apos;))

# 查看图文
@app.route(&apos;/detail/&lt;photo_id&gt;/&apos;)
def detail_a(photo_id):
photo_model = Article.query.filter(Article.id == photo_id).first()
return render_template(&apos;detail.html&apos;, photo = photo_model)

# 修改图文
def allowed_file1(filename1):
return &apos;.&apos; in filename1 and filename1.rsplit(&apos;.&apos;, 1)[1] in ALLOWED_EXTENSIONS

@app.route(&apos;/change/&apos;, methods = [&apos;GET&apos;, &apos;POST&apos;])
def change_a():
admin3_id = session.get(&apos;user_id&apos;)
if admin3_id:
    if request.method == &apos;GET&apos;:
        return render_template(&apos;change.html&apos;)
    else:
        file1 = request.files[&apos;file&apos;]
        content1 = request.form.get(&apos;content&apos;)
        photo_id = request.args.get(&apos;photo_id&apos;)
        if file1:
            if allowed_file(file1.filename):
                filename = secure_filename(file1.filename)
                file1.save(os.path.join(app.config[&apos;UPLOAD_FOLDER&apos;], filename))
            else:
                return u&apos;请按要求重新选择要上传的文件！&apos;
        else:
            pass
        photo1 = Article.query.filter(Article.id == photo_id).first()
        if file1:
            photo1.picture_path = file1.filename
        if content1:
            photo1.content = content1
        db.session.commit()
        return redirect(url_for(&apos;list_a&apos;))
else:
    return redirect(url_for(&apos;login_a&apos;))
</code></pre><p>一开始本来打算做个图文一起上传的，结果想想觉得图文直播大多数都是图片居多，而且很多时候下面并没有解释的文字，所以我觉得还是图片跟文字分开，各改各的。这里图片在后台显示是根据数据库中存储的图片名字，然后再去image文件中获取对应的图片。</p>
</the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用flask写图文直播网页（三）]]></title>
      <url>/2018/05/04/%E7%94%A8flask%E5%86%99%E5%9B%BE%E6%96%87%E7%9B%B4%E6%92%AD%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>图文直播</strong><br>既然是图文直播，那肯定需要管理员身份来上传图文吧，那么管理员信息存放在哪呢，登录注销要怎么弄呢(｡･ω･｡)<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>把基本的前端样式都弄好，然后就可以来实现它们的功能了哦（因为光有外表没有内涵是不行的嘛）(～￣▽￣)～ </p>
<p>一步一步来</p>
<p>###在mysql数据库中建表<br>由于小编使用的是mysql数据库（其他数据库都行，哪个熟练用哪个），接下来的先在mysql中建库（tuwen）、建两张表（admin、photo）admin用来存储管理员的账号密码，photo用来存储图片和文字信息。</p>
<p>modle.py</p>
<pre><code>from exts import db
from datetime import datetime

class Admin(db.Model):
__tablename__ = &apos;admin&apos;
id = db.Column(db.Integer, primary_key = True, autoincrement = True)
telephone = db.Column(db.String(20), nullable = False)
username = db.Column(db.String(100), nullable = False)
password = db.Column(db.String(100), nullable = False)

class Article(db.Model):
__tablename__ = &apos;photo&apos;
id = db.Column(db.Integer, primary_key = True, autoincrement = True)
picture_path = db.Column(db.String(100), nullable = True)
content = db.Column(db.Text, nullable = True)
create_time = db.Column(db.DateTime, default = datetime.now)
</code></pre><p>建完库跟表，下面就要进行数据库连接了</p>
<pre><code>SQLALCHEMY_DATABASE_URI = &apos;mysql+pymysql://root:root@localhost:3306/tuwen?charset=utf8&apos;
SQLALCHEMY_TRACK_MODIFICATIONS = True
</code></pre><p>###实现登录功能<br>sc.py</p>
<pre><code>  # 登录
@app.route(&apos;/login/&apos;, methods = [&apos;POST&apos;, &apos;GET&apos;])
def login_a():
if request.method == &apos;GET&apos;:
    return render_template(&apos;login.html&apos;)
else:
    telephone = request.form.get(&apos;telephone&apos;)
    password = request.form.get(&apos;password&apos;)
    user = Admin.query.filter(Admin.telephone == telephone, Admin.password == password).first()
    if user:
        session[&apos;user_id&apos;] = user.id
        session.permanent = True
        return redirect(url_for(&apos;upload_file&apos;))
    else:
        return u&apos;账号或密码输入错误，请确认后重新输入！&apos;
</code></pre><p>###实现登出功能</p>
<p>sc.py</p>
<pre><code># 登出
@app.route(&apos;/logout/&apos;)
def logout_a():
session.clear()
return redirect(url_for(&apos;login_a&apos;))
</code></pre><p>相比较登录，登出的代码就少的多，清除session缓存就行了</p>
<p>###实现注销功能<br>sc.py</p>
<pre><code># 注销
@app.context_processor
def my_context_processor():
user_id = session.get(&apos;user_id&apos;)
if user_id:
    user = Admin.query.filter(Admin.id == user_id).first()
    if user:
        return {&apos;user&apos;: user}
return {}
</code></pre><p>最后不要忘记在父模板中连接对应的按钮，比如：<br>base.html</p>
<pre><code>&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
                    {% if user %}
                                <li><a href="#">管理员</a></li>
                                <li><a href="{{ url_for('logout_a') }}">注销</a></li>
                          {% else %}
                                <li><a href="{{ url_for('login_a') }}">登录</a></li>
                          {% endif %}
&lt;/ul&gt;
</code></pre></the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用flask写图文直播网页（二）]]></title>
      <url>/2018/05/04/%E7%94%A8flask%E5%86%99%E5%9B%BE%E6%96%87%E7%9B%B4%E6%92%AD%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>图文直播</strong><br>flask框架用起来确实很方便，特别适合新手，下面就来看看flask做一个图文直播网页吧..<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>其实我也是新手，框架结构什么的还不懂的怎么弄，然后我放的就比较简单</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-2ccd30b66533ee4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构"></p>
<p>其中，static里面放css跟images、image文件，image里面放的是图文直播内容的图片，images里面放的是图文直播标题的背景图。</p>
<p>首先说一下后台主界面吧，后台样式是从bootstrip上复制的基本模本，然后自己稍加改动形成的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-3c2be088c4ea59ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后台页面样式"></p>
<p>这样后台做起来会更简单点，直接从bootstrip上找一个自己喜欢的后台管理模板，然后copy到templates下的base.html里就行了，然后以此作为父后台模板。</p>
<p>其他的页面可以继承父模板的样式。<br>base.html中还会预留一下一些主体和页面标题等一些接口，这样其他的页面可以在继承了父模板的页面上随心所欲的改动其他部分</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-ca6716887957dbff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后台主界面代码展示"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-85d684bdcf738f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="管理员登录界面"></p>
<p>然后通过这种方法再加上CSS代码的一些控制，你就可以把管理界面改成自己喜欢的样子（好像我做的有点low啊  0.0，css学的不好，伤心一秒T.T）</p>
</the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用flask写图文直播网页（一）]]></title>
      <url>/2018/05/04/%E7%94%A8flask%E5%86%99%E5%9B%BE%E6%96%87%E7%9B%B4%E6%92%AD%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>图文直播</strong><br>flask框架用起来确实很方便，特别适合新手，下面就来看看flask做一个图文直播网页吧..<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<blockquote>
<p>这个东西也可以说是我初学flask的成果展示吧（有点菜，勿喷哦0.0）<br>先上一波最终展示图吧</p>
</blockquote>
<p>　　　　<img src="https://upload-images.jianshu.io/upload_images/6755082-29160d05bfe34527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标题"></p>
<p>　　　<img src="https://upload-images.jianshu.io/upload_images/6755082-8425e87a66187f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="展示"></p>
<blockquote>
<p>既然是图文直播，那么后台的管理肯定是不能少的，再来看看后台的管理模式吧</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-ed230e45384befb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="管理员登录界面"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-bb7ef94d476b50b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图文上传界面"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6755082-6a8bda149776c415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图文管理界面"></p>
</the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ERROR 1820 (HY000) You must reset your password]]></title>
      <url>/2017/10/28/mysql--ERROR%EF%BC%881820%EF%BC%89%E5%AF%86%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>登录mysql的root账户后不能进行其他操作：</strong><br>mysql好难弄啊，最近弄好了root密码问题，现在又出来个root账户进入后不能进行操作，到底怎么解决呢，来看看吧。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<p>非常诡异啊，明明用密码登陆进去了，怎么还提示需要密码。什么操作都不许<br>参考官方的一个文档，见<a href="http://dev.mysql.com/doc/refman/5.6/en/alter-user.html。" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.6/en/alter-user.html。</a>如下操作后就ok了： </p>
<p>mysql&gt; create database school;<br>ERROR 1820 (HY000): You must SET PASSWORD before executing this statement<br>mysql&gt; set password = password(‘123456’);<br>Query OK, 0 rows affected (0.03 sec) </p>
<p>mysql&gt; create database school;<br>Query OK, 1 row affected (0.00 sec) </p>
<p>其实就是用（set password = password(‘123456’)这个命令重置一下密码）好了问题解决，现在继续操作你的mysql吧。</p>
</the>]]></content>
      
        <categories>
            
            <category> know </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下修改MySQL5.7.11(以上)的root密码]]></title>
      <url>/2017/10/25/windows%E4%B8%8B%E4%BF%AE%E6%94%B9MySQL5.7.11%E7%9A%84root%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>修改mysql的root密码：</strong><br>mysql的最新版本5.7.18安装后除了第一次启动服务root账户正确，以后启动root都显示密码错误。对待这种情况应该怎么解决呢？<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>到mysql的官网下载最新的5.7.18版本的mysql，按照教程安装好，一般默认在C盘的Program Files文件夹里，mysql的数据文件在C盘的Program Data文件夹里。</p>
<h2 id="环境变量进配置："><a href="#环境变量进配置：" class="headerlink" title="环境变量进配置："></a>环境变量进配置：</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-ad18aefd6d56f3d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="几个命令："><a href="#几个命令：" class="headerlink" title="几个命令："></a>几个命令：</h2><pre><code>安装 MySQL 服务: mysqld --install

启动: net start MySQL

停止: net stop MySQL

卸载: sc delete MySQL，mysqld -remove

初始化data文件： mysqld --initialize
</code></pre><p>命令行安装也可以，注意：命令行窗口一定要用管理员模式打开，来到%MYSQL_HOME%\bin;这个目录下，<br>a.安装服务：mysqld –install。<br>b.启动服务 net start MySQL</p>
<h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><ul>
<li>输入命令 mysql -uroot -p 回车，输入密码，按理说初次登录是没有密码的，直接回车即可登录，然而事实上，随机分配了密码，在你的文件中搜索 .err后缀的文件，以记事本方式打开，你会看到下图<br><img src="http://upload-images.jianshu.io/upload_images/6755082-b7795533f4c2d785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h2 id="root密码进不去"><a href="#root密码进不去" class="headerlink" title="root密码进不去"></a>root密码进不去</h2><ul>
<li>启动成功了，（安装在默认C盘的Program Files文件夹里的可以直接在命令行里输入mysql的登录指令，没有安装在默认C盘的，这时候必须先进入到mysql文件夹的bin文件夹下）输入命令mysql -uroot -p 回车（这是进入mysql的root账户命令）</li>
<li>输入密码，显示错误ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)，看着上面说的，输入YES就好了，很开心，以为发现了很激动的信息，就理所当然的输入了YES等待进去，别天真了，没任何作用。这时候无论怎么输密码都是显示ERROR 1045，没办法只有重置密码。</li>
<li>把data文件夹删掉，用mysqld –initialize（两个‘-’）不行的话用（mysqld –initialize-insecure这个命令就可以了。也是两个‘-’） 初始化data目录即可。删不掉data的时候，把任务管理器打开kill掉mysqld进程,其他启动或者关闭服务失败的时候一样做法。）</li>
</ul>
<h2 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h2><ul>
<li>关闭服务net stop MySQL，用安全模式打开，mysqld –skip-grant-tables。这个时候，光标会一直闪。注意，千万别急按回车或者关闭，这时候千万不要动，打开另一个命令行窗口。（安装在默认C盘的Program Files文件夹里的可以直接在命令行里输入mysql的登录指令，没有安装在默认C盘的，这时候必须先进入到mysql文件夹的bin文件夹下）登录 mysql -u root -p密码为空,直接回车；就可以进去了。然后use mysql;</li>
<li>（可能先前的版本密码的抬头是password，5.7.11是 authentication_string,可以select * from user,查看一下）</li>
<li>(老版本)update user set password=password(“123456”) where user=”root”;</li>
<li>（5.7.11以上版本）update user set authentication_string=password(“123456”) where user=”root”;</li>
<li>最后，flush privileges;（ 命令本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。）就OK了。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-6046f76a8065e211.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="退出去重新登录一下试试看："><a href="#退出去重新登录一下试试看：" class="headerlink" title="退出去重新登录一下试试看："></a>退出去重新登录一下试试看：</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-969697ba39446e18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</the>]]></content>
      
        <categories>
            
            <category> know </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重定向对象redirect]]></title>
      <url>/2017/09/26/%E9%87%8D%E5%AE%9A%E5%90%91%E5%AF%B9%E8%B1%A1redirect/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>redirect</strong><br>重定向是一种特殊的响应，响应内容是URL，而不是包含html代码的字符串。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<blockquote>
<p>重定向是一种特殊的响应， 响应内容是URL，而不是包含HTML 代码的字符串。浏览器收到这种响应时， 会向重定向的URL 发起 GET 请求，显示页面的内容。</p>
</blockquote>
<p>　　下面是一段代码，正常运行时候都是显示“这是首页”</p>
<pre><code>from flask import Flask

app = Flask(__name__)

@app.route(&apos;/&apos;)
def index():
  return &apos;这是首页&apos;

@app.route(&apos;/login/&apos;)
def login():
  return &apos;欢迎登录&apos;
</code></pre><blockquote>
<p>加上redirect函数后再次运行都会显示“欢迎登陆”，就是自动跳到登陆（login）界面去了</p>
</blockquote>
<pre><code>from flask import Flask,redirect,url_for

app = Flask(__name__)

@app.route(&apos;/&apos;)
def index():
  login_url = url_for(&apos;login&apos;)
  return redirect(login_url)
  return &apos;这是首页&apos;

@app.route(&apos;/login/&apos;)
def login():
  return &apos;欢迎登录&apos;
</code></pre><blockquote>
<p>当用户访问某些网页时，如果他还没登录，我们往往会把网页 重定向 到登录页面，Flask 提供了 redirect 对象对其进行处理，我们对上面的代码做一点简单的改造，如果用户注册了，我们将网页重定向到首页。</p>
</blockquote>
<pre><code>from flask import Flask,redirect,url_for

app = Flask(__name__)

@app.route(&apos;/&apos;)
def index():
  login_url = url_for(&apos;login&apos;)
  return redirect(login_url)
  return &apos;这是首页&apos;

@app.route(&apos;/login/&apos;)
def login():
  return &apos;欢迎登录&apos;

@app.route(&apos;/message/&lt;a_login&gt;/&apos;)
def message(a_login):
  if a_login==&apos;1&apos;:
    return &apos;欢迎查看资料信息&apos;
  else:
    return redirect(url_for(&apos;login&apos;))
</code></pre><blockquote>
<p>推荐使用url_for() 生成 URL，因为这个函数使用URL 映射生成 URL，从而保证URL 和定义的路由兼容，而且修改路由名字后依然可用。url_for()函数的第一个且唯一必须指定的参数是端点名，即路由的内部名字。 默认情况下，路由的端点是相应视图函数的名字。</p>
</blockquote>
</the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flask框架-debug模式]]></title>
      <url>/2017/09/26/Flask%E6%A1%86%E6%9E%B6-debug%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>debug模式：</strong><br>debug模式为我们写flask提供了很大的便利<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">





<p>debug模式在我们写flask的时候提供了两点好处</p>
<h2 id="第一点"><a href="#第一点" class="headerlink" title="第一点"></a>第一点</h2><p>当程序出现问题的时候，可以在页面中看到错误信息和错误位置；</p>
<p>下面给出一个简单小程序：</p>
<pre><code>from flask import Flask
app = Flask(__name__)

@app.route(&apos;/&apos;)
def hello_world():
  a = 1
  b = 0
  c = a / b
  return &apos;第一个flask程序&apos;

if __name__ == &apos;__main__&apos;:
  app.run()
</code></pre><p>代码里面有个除零的运算，当没有使用debug时候界面是下面这样子的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-dd575d98f45e5731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面代码使用debug模式</p>
<pre><code>from flask import Flask

app = Flask(__name__)

@app.route(&apos;/&apos;)
def hello_world():
  a = 1
  b = 0
  c = a / b
  return &apos;第一个flask程序&apos;

if __name__ == &apos;__main__&apos;:
  app.run(debug=True)
</code></pre><p>输出框显示结果<br><img src="http://upload-images.jianshu.io/upload_images/6755082-bf311c949d11746e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="提示错误原因"></p>
<p>界面显示结果<br><img src="http://upload-images.jianshu.io/upload_images/6755082-264135adb4f8f191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="显示错误位置"></p>
<h2 id="第二点"><a href="#第二点" class="headerlink" title="第二点"></a>第二点</h2><p>只要修改了项目中的python文件（必须是python文件），程序会自动加载，不需要重新启动服务器。</p>
</the>]]></content>
      
        <categories>
            
            <category> know </category>
            
        </categories>
        
        
        <tags>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分组密码--DES算法]]></title>
      <url>/2017/07/19/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>密码学</strong><br>DES算法是分组密码里面的常用算法，它是一种对称密码，加密和解密都是同一个密钥。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h2 id="什么是DES算法"><a href="#什么是DES算法" class="headerlink" title="什么是DES算法"></a>什么是DES算法</h2><p>　　DES是一种对称密码，加密和解密用的都是同一个密钥，有效密钥长度为56位。DES是一个分组密码算法，分组长度为64位，即对数据进行加解密的单位是64位，明文和密文的长度相同。由于加密和解密用的是同一算法，所以有利于硬件和软件上的实现。注意上面说的56位是有效密钥长度，事实上我们用的是64位密钥，但是第8,16,24,32,40,56和64位是奇偶校验位</p>
<h2 id="DES算法的概述"><a href="#DES算法的概述" class="headerlink" title="DES算法的概述"></a>DES算法的概述</h2><p>　　</p>
<h4 id="1-分组的加密算法"><a href="#1-分组的加密算法" class="headerlink" title="1.分组的加密算法"></a>1.分组的加密算法</h4><p>　　明文和密文为64位分组长度。</p>
<h4 id="2-对称算法"><a href="#2-对称算法" class="headerlink" title="2.对称算法"></a>2.对称算法</h4><p>　　加密和解密除密钥编排不同外，使用同一算法。</p>
<h4 id="3-密钥长度"><a href="#3-密钥长度" class="headerlink" title="3.密钥长度"></a>3.密钥长度</h4><p>　　56位，但存在弱密钥，容易避开。</p>
<h4 id="4-采用混乱和扩散的组合，每个组合先替代后置换，共16轮"><a href="#4-采用混乱和扩散的组合，每个组合先替代后置换，共16轮" class="headerlink" title="4.采用混乱和扩散的组合，每个组合先替代后置换，共16轮"></a>4.采用混乱和扩散的组合，每个组合先替代后置换，共16轮</h4><h4 id="5-只使用了标准的算术和逻辑运算，易于实现"><a href="#5-只使用了标准的算术和逻辑运算，易于实现" class="headerlink" title="5.只使用了标准的算术和逻辑运算，易于实现"></a>5.只使用了标准的算术和逻辑运算，易于实现</h4><h4 id="6-现代密码学诞生的标志之一，揭开了商用密码研究的序幕"><a href="#6-现代密码学诞生的标志之一，揭开了商用密码研究的序幕" class="headerlink" title="6.现代密码学诞生的标志之一，揭开了商用密码研究的序幕"></a>6.现代密码学诞生的标志之一，揭开了商用密码研究的序幕</h4><h2 id="DES加密流程图"><a href="#DES加密流程图" class="headerlink" title="DES加密流程图"></a>DES加密流程图</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-ff18a32847730b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="DES算法的实现"><a href="#DES算法的实现" class="headerlink" title="DES算法的实现"></a>DES算法的实现</h2><p>（一）初始置换（IP）。将明文块的位进行换位，其置换表示固定的。初始置换表为8*8的表格，第一位58表示该位置存放明文中的第58位字符。第1位字符已经变换到40位的位置。<br>　　注意初始置换是固定公开的函数，因此没有密码的意义。作用不大，它们的作用在于打乱原来输入x的ASCII码字划分的关系。经过初始置换之后，64位明文分成了两组L和R,各32位。由于这种方法软件实现较为麻烦，所有很多软件实现都删去了初始置换。经过初始置换，64位的输入得到了两个32位的输出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-b811c9eed4f2ae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>（二）16轮的轮函数F变换。轮函数F由3个部分组成：扩展置换（E盒），非线性代换（S盒）和线性置换（P盒）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-541483a04dc96b1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>（1）E盒的作用是将32为扩展为48位，其扩展规则按下表进行。该表大小为6*8，去掉最左和最右两行，中间的四列包含了1-32的顺序。第1列和第6列分别是对第4和第1列的扩展。经过扩展置换，32位的输入得到了48位的输出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-521341ec596d03d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>（2）S盒的作用是进行非线性代换。S盒是DES中唯一的非线性部分，DES的安全强度主要取决于S盒的安全程度。S盒运算其实是一个查表运算。在E盒的扩展之后得到了48位的数据，将其和48位的子密钥进行异或运算，这是密钥参与运算的步骤。将其分成8个组，每组6个，送到8个S盒中去。每一个S盒都是一个6位输入4位输出的结构，也就是说，48位输入到8个S盒会得到4*8=32位的输出。6位输入到8位输出的映射关系如下表所示，其中，第一位和最后一位作为行号，第二位到第五位最为列号。例如，101100，则行号为10=2，列号为0110=6。查得（2,6）=2，化成二进制位0010。注意，8个S盒的映射关系各不相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-f2952fc17cae1f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>（3）P盒的作用只是进行简单的位置置换，只是简单地把一位换成另一位，不进行扩展和压缩。经过P盒操作，32位的输入得到32位的输出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-05e4d2b313fb2367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>轮函数F剩下的步骤通过轮函数的组成图可以清晰看出，这里不再详细介绍。主要就是进行异或操作。就这样对经过E盒拓展的64位数据进行16轮的变换。</p>
<p>（三）逆初始置换。如果进行初始置换，则必须进行逆初始置换，逆初始置换的实现和初始置换一样，只是置换表不同而已。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-aa2d106b363ef69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="DES子密钥生成方法"><a href="#DES子密钥生成方法" class="headerlink" title="DES子密钥生成方法"></a>DES子密钥生成方法</h2><p> 　　DES的初始64位密钥通过置换选择PC-1得到有效的56位密钥。这56位分为2个28位数据C0和D0。每轮迭代中Ci-1和Di-1分别循环左移1位或2位，移位后的值作为下一轮的输入，同时也作为置换选择PC-2的输入，通过置换选择PC-2产生一个48位的输出，即为一个子密钥。64位密钥生成了16个48位的子密钥。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-ccc9f1461e355e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="PC-1表（用于置换选择1）"><a href="#PC-1表（用于置换选择1）" class="headerlink" title="PC-1表（用于置换选择1）"></a>PC-1表（用于置换选择1）</h3><p><img src="http://upload-images.jianshu.io/upload_images/6755082-ea46e4e9d8839b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="PC-2表（用于置换选择2）"><a href="#PC-2表（用于置换选择2）" class="headerlink" title="PC-2表（用于置换选择2）"></a>PC-2表（用于置换选择2）</h3><p><img src="http://upload-images.jianshu.io/upload_images/6755082-6d206e04df0359ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="DES的核心技术"><a href="#DES的核心技术" class="headerlink" title="DES的核心技术"></a>DES的核心技术</h2><h4 id="S盒设计准则"><a href="#S盒设计准则" class="headerlink" title="S盒设计准则"></a>S盒设计准则</h4><p>　　1.具有良好的非线性；<br>　　2.每一行包括所有16种4位二进制；<br>　　3.两个输入相差1比特时，输出相差2比特；<br>　　4.如果两个输入刚好在中间两个比特上不同，则输出至少有输入至少有两个比特不同；<br>　　5.如果两个输入前两位不同而最后两位相同，则输出一定不同。</p>
<h4 id="P盒设计准则"><a href="#P盒设计准则" class="headerlink" title="P盒设计准则"></a>P盒设计准则</h4><p>　　1.每个S盒的4位输出影响下一轮6个不同的S盒，但是没有两位影响同一S盒；<br>　　2.在第i轮S盒的4位输出中，2位将影响i+1轮中间位置，其余2位数将影响两端位；<br>　　3.如个一个S盒的4位输出影响另一个S盒的中间的一位，则后一个的输出位不会影响前面一个S盒的中间位。</p>
<h4 id="DES的解密算法"><a href="#DES的解密算法" class="headerlink" title="DES的解密算法"></a>DES的解密算法</h4><p><img src="http://upload-images.jianshu.io/upload_images/6755082-1fe61efcfb970f53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="DES解密流程图"><a href="#DES解密流程图" class="headerlink" title="DES解密流程图"></a>DES解密流程图</h4><p><img src="http://upload-images.jianshu.io/upload_images/6755082-aa8da009593d8f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</the>]]></content>
      
        <categories>
            
            <category> communication </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分组密码]]></title>
      <url>/2017/07/19/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>密码学</strong><br>分组密码是将一段很长的明文消息经过编码表示后的二进制序列划分为若干个固定长度，一一加密。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h2 id="分组密码的处理方式"><a href="#分组密码的处理方式" class="headerlink" title="分组密码的处理方式"></a>分组密码的处理方式</h2><p>（1）分组密码算法只负责固定长度消息的加、脱密；<br>（2）工作模式负责长消息的处理方式；<br>（3）短块处理方式负责短块处理方式的约定</p>
<h2 id="分组密码的含义"><a href="#分组密码的含义" class="headerlink" title="分组密码的含义"></a>分组密码的含义</h2><p>　　也称块密码，它是将明文消息经过编码表示后的二进制序列m0，m1，……，mi，……划分成若干个固定长度（p）的组（或块）m=（m0，m1,……,mn），各组分别在密钥K=（K0，K1，……,Kt-1）的控制下转换成长度为n的密文分组C=（C0，C1，……,Cn-1）。其本质是一个从明文空间（m长的比特串的集合）P到密文空间（n长的比特串的集合）C的一一映射。（一般而言，p=n）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-cb44a11dc4e23801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="分组密码的要求"><a href="#分组密码的要求" class="headerlink" title="分组密码的要求"></a>分组密码的要求</h2><h3 id="1-分组长度要足够大"><a href="#1-分组长度要足够大" class="headerlink" title="1.分组长度要足够大"></a>1.分组长度要足够大</h3><p>　　当分组长度较小时候，攻击者通过穷举明文空间，得到密码变换规律，难以抵挡选择明文攻击。</p>
<h3 id="2-密钥量要足够大"><a href="#2-密钥量要足够大" class="headerlink" title="2.密钥量要足够大"></a>2.密钥量要足够大</h3><p>　　如果密钥量小，攻击者可以有效地通过穷举密钥，对密文进行解密，来得到有意义的明文，难以抵挡唯密文攻击。</p>
<h3 id="3-密码变换足够复杂"><a href="#3-密码变换足够复杂" class="headerlink" title="3.密码变换足够复杂"></a>3.密码变换足够复杂</h3><p>　　使攻击者出了穷举法攻击以外，找不到其它有效地数学破译方法。</p>
<h3 id="4-加密解密运算简单"><a href="#4-加密解密运算简单" class="headerlink" title="4.加密解密运算简单"></a>4.加密解密运算简单</h3><p>　　便于软件和硬件的实现，性能好。</p>
<h3 id="5-无数据扩展和压缩"><a href="#5-无数据扩展和压缩" class="headerlink" title="5.无数据扩展和压缩"></a>5.无数据扩展和压缩</h3><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>　　使用迭代方式，由简单得、容易实现的模块搭建出抗破译能力强的分组密码算法；<br>　　每个模块各司其责、互相弥补对方的缺点，合作完成分组密码算法的搭建工作。</p>
<h3 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h3><p>　　扩散是指要将算法设计成明文每一比特的变化尽可能多的影响到输出密文序列的变化，以便隐蔽明文的统计特性。形象地称为雪崩效应。<br>　　扩散的另外一层意思是密钥每一位的影响尽可能迅速地扩展到较多的密文比特中去。即扩散的目的是希望密文中的任一比特都要尽可能与明文、密钥相关联，或者说，明文和密钥中的任一比特值发生改变，都会在某种程度上影响到密文值得变化，以防止将密钥分解成若干个孤立小部分，然后各个击破。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-a9b0a12eb469c59e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="混乱"><a href="#混乱" class="headerlink" title="混乱"></a>混乱</h3><p>　　混乱，指在加解密变换过程中明文、密钥以及密文之间的关系尽可能地复杂化，以防密码破译者采用解析法（即通过建立并求解一些方程）进行破译攻击。<br>　　混乱可以用“搅拌机”来形象地解释，将一组明文和一组密钥输入到算法中，经过充分混合，最终变成密文。同时要求，执行这种“混乱”作业的每一步都必须是可逆的，即明文混乱以后能得到密文，反之，密文经过逆向的混乱操作后能恢复到明文。（按照混乱原则，分组密码算法应该有复杂的非线性因素）</p>
<h2 id="分组密码的原理–乘积密码"><a href="#分组密码的原理–乘积密码" class="headerlink" title="分组密码的原理–乘积密码"></a>分组密码的原理–乘积密码</h2><p>　　依次使用两个或者两个以上的基本密码，所得结果的密码强度将强于所有单个密码的强度，即乘积密码是扩散和混乱两种基本密码操作的组合变换，这样能够产生比个子单独使用时更强大的密码系统。选择某个较为简单的密码变换（包含多个基本密码），在密钥控制下以迭代方式多次利用它进行加密变换，就可以实现预期的扩散和混乱效果。</p>
<h2 id="乘积密码的实现–SP网络"><a href="#乘积密码的实现–SP网络" class="headerlink" title="乘积密码的实现–SP网络"></a>乘积密码的实现–SP网络</h2><p>　　SP网络是由多重S变换和P变换组合成的变换网络，它是乘积密码的一种。其基本操作是S变换（代替）和P变换（换位），前者称为S盒，后者称为P盒。S盒起到混乱作用，P盒起到扩散的作用。SP网络的构造及S盒、P盒的构造如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-f633893e3431a069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="SP网络的性质"><a href="#SP网络的性质" class="headerlink" title="SP网络的性质"></a>SP网络的性质</h2><p>　　SP网络具有雪崩效应。所谓雪崩效应是指，输入（明文或密钥）即使只有很小的变化，也会导致输出产生巨大的变化现象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-b08579b125abccdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="分组密码简图"><a href="#分组密码简图" class="headerlink" title="分组密码简图"></a>分组密码简图</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-4dcc36968770df55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="分组密码的设计准则"><a href="#分组密码的设计准则" class="headerlink" title="分组密码的设计准则"></a>分组密码的设计准则</h2><h3 id="分组长度"><a href="#分组长度" class="headerlink" title="分组长度"></a>分组长度</h3><p>　　能够抵御选择明文攻击</p>
<h3 id="密钥长度"><a href="#密钥长度" class="headerlink" title="密钥长度"></a>密钥长度</h3><p>　　能够抵御唯密文攻击</p>
<h3 id="轮函数（圈函数）F的设计准则"><a href="#轮函数（圈函数）F的设计准则" class="headerlink" title="轮函数（圈函数）F的设计准则"></a>轮函数（圈函数）F的设计准则</h3><p>　　轮函数F是分组密码的核心，是分组密码中单轮加密解密函数，其基本准则：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-b47103e7974b6256.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>　　其主要性能指标是：安全性、速度、灵活性。</p>
<h3 id="子密钥的生成方法"><a href="#子密钥的生成方法" class="headerlink" title="子密钥的生成方法"></a>子密钥的生成方法</h3><p>　　子密钥的生成也是也是迭代分组算法的一个重要组成部分，是从初始（种子）密钥产生迭代的各轮要使用的子密钥的算法。也就是说，轮函数F的功能是在子密钥的参与和控制下实现的子密钥的生成很重要，其评价指标：<br>　　1.实现简单、速度满足要求；<br>　　2.种子密钥的所有比特对每个字密钥比特的影响应大致相同；<br>　　3.没有弱密钥或弱密钥容易确定。</p>
<h3 id="迭代的轮数"><a href="#迭代的轮数" class="headerlink" title="迭代的轮数"></a>迭代的轮数</h3><p>　　分组密码一般采用简单的、安全性弱的加密函数进行多轮迭代运算，使得安全性增强。一般来说，分组密码迭代轮数越多，密码分析越困难，但也不是追求迭代数越多越好，过多迭代轮数会使加密算法的性能下降，而安全性增强不明显。决定迭代轮数的准则：使密码分析的难度大于简单穷举搜索攻击的难度。分组密码迭代轮数一般采用8,10,12,16,20的居</p>
</the>]]></content>
      
        <categories>
            
            <category> communication </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列密码--A5-1算法]]></title>
      <url>/2017/07/19/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-A5-1%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>密码学</strong><br>A5-1算法用于移动电话中的语音加密，来看看原理吧。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h3 id="A5-1算法"><a href="#A5-1算法" class="headerlink" title="A5-1算法"></a>A5-1算法</h3><p>  　　　　<img src="http://upload-images.jianshu.io/upload_images/6755082-618edbac1898d8ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>　　Ａ5-1算法用于蜂窝式移动电话系统中的语音加密，主要用于用于的手机到基站之间的加密通信。通信内容到基站后先脱密变成明文，然后在进行基站到基站之间、以及基站到用户手机之间的信息加密，完成通信内容在通信过程的加密保护。<br>　　每次通话的时候，基站会产生一个64比特的随机数，与我们手机sim卡内本身带的一个密码利用一种加密算法生成一个密钥，这个密钥就是这次通话过程中使用的主密钥，此密钥的生命周期为这一次通话的开始到结束。一旦通话完成，那么这个密钥也就没有用了。<br>　　该加密算法把整个通讯的数据划分为每一帧来进行加密。每一帧是有228比特，其中发送端给接收端的数据114比特，接收端反馈给发送端的数据有114比特。除了上面提出的基站给出的64比特的总密钥，针对每一帧的加密，还有一种叫做会话密钥，这种会话密钥每加密一帧都会改变，会话密钥的生成是由帧号来决定的。每一次的会话密钥都会产生一个228比特的乱数来加密这一帧的数据。加密的方式是异或。帧号一共用22比特的二进制数来表示，也就是说一次通话只能传递2^22次方的通讯数据，因为每一次通话只有这么多帧可以进行加密数据并且传递。</p>
<p>　　A5-1算法基于三个线性移位反馈寄存器实现的。三个LFSR的级数分别是19 22 23。<br>f1(x) = x^19 + x^18 + x^17 + x^14 + 1<br>f2(x) = x^22 + x^21 + 1<br>f3(x) = x^23 + x^22 + x^21 + x^8 + 1<br>三个反馈多项式如上所示。</p>
<h3 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h3><p>　　根据上面所讲的，如果要实现a5-1的加密算法，我们需要哪些工具：首先是明文，其次是64位的密钥，三个LFSR，以及帧号。<br>　　算法的输入应该就是三个LFSR的初始值，算法的输出就是我们加密明文所需要的乱数。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>　　算法总体来说分为三个部分，初始化，运算，输出乱数<br><img src="http://upload-images.jianshu.io/upload_images/6755082-50684bf88f426601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>首先是初始化部分：<br>（1）将三个寄存器内的所有位全都赋值为0<br>（2）将三个寄存器做64次的移位操作，每第i次操作，寄存器的反馈内容都先与密钥中的第i位进行异或，然后把这样异或的结果作为寄存器此次的反馈内容。三个LSFR都要并行的做这样的工作64次。<br>（2）将三个寄存器做22次的移位操作，没第i次操作，寄存器的反馈项都先与帧序号的第i位进行异或，将异或的结果作为寄存器的最终反馈内容，同样，三个LSFR也都要并行做22次。<br>上述三步做完，A5-1加密算法的初始化操作也就做完了。另外需要注意的是，A5-1加密算法的LSFR是左移操作，并且，密钥和帧号都是从最低位到最高位编号。<br>当初始化步骤完成的时候，此时三个LSFR的状态合称为S0状态。</p>
<p>接下来是计算和输出部分：<br>大家可以看到，上面的逻辑结构图中，有一个叫做钟控的部分，他有三个输出三个输入，三个输入是分别来三个LSFR的某一个固定位，输入会输出0或者1.0表示此次这个LSFR不会工作，也就是不会发生移动等等，输出的是1的话，那么这个LSFR此次就会移动一位并且得出反馈的结果。也就是说这个钟控在控制着三个LSFR的工作与否。<br>首先根据钟控的方式三个LSFR连续移动100次，但是不输出乱数，此时应该只是做一个混乱的操作。因为LSFR在移动过程中，每一位寄存器内的数值都会不一样，所以在钟控决定每个寄存器运行与否的结果时也会不相同。<br>接下来会三个LSFR会接着进行连续的114次的移动，也是根据钟控的方式。这一次的移动过程中，三个寄存器将分别把最高位寄存器的值输出，然后三个值做异或运算，形成第i个乱数。这次114次移动会生成一个114位的乱数，用于对手机到基站这一段的数据加密。<br>之后再进行一次100次的移动和114次的移动，结果和上面说的相同，最终产生的114位密钥用于基站到手机这段的通讯数据加密。</p>
<p>关于钟控：<br>钟控将第一个寄存器的第八位，第二个寄存器的第10位，第三个寄存器的第10位。抽取这三个位用于控制三个LSFR的动作与否。他们决定的原则类似少数服从多数，三位一共有8种排列方式，当三位中1的个数多余0的个数时，那么这三位是1的对应的寄存器将会移动， 为0的不会，如果三位数中0的个数多余1的个数时，那么三位之中是0的对应的寄存器将会移动。<br><img src="http://upload-images.jianshu.io/upload_images/6755082-4696904361b80e3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-ee6ec06af28933fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-2871257ac01145e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>根据上面的步骤就可以算出当我们把通讯数据切割成每一帧，然后对每一帧进行加密传输的时候，所需要的那个加密的乱数是怎么得来的。至于加密过程很简单，就是明文和乱数的异或操作。</p>
</the>]]></content>
      
        <categories>
            
            <category> communication </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列密码]]></title>
      <url>/2017/07/18/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>序列密码</strong><br>序列密码在当今无论是生活中，外交还是军事都应用广泛。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="什么是序列密码"><a href="#什么是序列密码" class="headerlink" title="什么是序列密码"></a>什么是序列密码</h2><p>　　使用序列密码对某一消息m执行加密操作时一般是先将m分成连续的符合（一般为比特串），m=m1m2m3…;然后使用密钥流k=k1k2k3…中的第i个元素ki对明文消息的第i个元素mi执行加密变换，i=1,2,3…；所有的加密输出连接在一起就构成了对m执行加密后的密文。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-2c5e7c5c635152ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>真正意义上的随机数（或者随机事件）在某次产生过程中是按照实验过程中表现的分布概率随机产生，是不可见的。</p>
<h3 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h3><p>计算机中的随机函数是按照一定的算法模拟产生的，其结果是确定的，是可见的，我们可以这样认为这个可预见的结果其出现的概率是100%。所以计算机随机产生的“随机数”并不随机</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-cc410d31a2cd68d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="序列密码的应用场景"><a href="#序列密码的应用场景" class="headerlink" title="序列密码的应用场景"></a>序列密码的应用场景</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-0904b51c04970c5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-2a44c8831c394d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-90083613ebd20cd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-fb60acb9a691bc7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-4b5775e48284e74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="典型序列密码算法"><a href="#典型序列密码算法" class="headerlink" title="典型序列密码算法"></a>典型序列密码算法</h2><ol>
<li>A5-1算法       </li>
<li>SNOW算法</li>
<li>ZUC算法</li>
<li>Trivium算法</li>
</ol>
</the>]]></content>
      
        <categories>
            
            <category> communication </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[密码学简介]]></title>
      <url>/2017/07/18/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>密码学</strong><br>密码学是以秘密通信为目的，研究密码编制、密码分析和密钥管理的一门综合性应用科学。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p><img src="http://upload-images.jianshu.io/upload_images/6755082-f3efe087eb73a5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="棋盘密码"><a href="#棋盘密码" class="headerlink" title="棋盘密码"></a>棋盘密码</h3><p><img src="http://upload-images.jianshu.io/upload_images/6755082-bbd6134af995ed51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="网格密码"><a href="#网格密码" class="headerlink" title="网格密码"></a>网格密码</h3><p><img src="http://upload-images.jianshu.io/upload_images/6755082-19daf30407675c2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>　 </p>
<blockquote>
<p>密码学是以秘密通信为目的，研究密码编制、密码分析和密钥管理的一门综合性应用科学。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/6755082-767739c865e20e32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">
　</p>
<blockquote>
<p>密码编码学像盾一样保护自己，研究如何编制密码进行秘密通信的科学，分析学像矛一样，是个研究如何破解对方秘密的科学，密钥管理学是最重要的，它是研究如何产生、分配、管理密钥的科学，三者相辅相成，是一个有机整体。</p>
<h2 id="密码通信的基本结构"><a href="#密码通信的基本结构" class="headerlink" title="密码通信的基本结构"></a>密码通信的基本结构</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-d333dd93751ac5f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>密钥一定要保密，其他公开信道上传输，包括加密算法，密文等都是公开信息，也就这些是可以被第三方截获的。</p>
<h2 id="密码学的主要功能"><a href="#密码学的主要功能" class="headerlink" title="密码学的主要功能"></a>密码学的主要功能</h2><h3 id="1-机密性"><a href="#1-机密性" class="headerlink" title="1.机密性"></a>1.机密性</h3><p>　　<br>防止恶意第三方（信道上的EVE）也就是非法授权者获取信息；</p>
<h3 id="2-真实性认证"><a href="#2-真实性认证" class="headerlink" title="2.真实性认证"></a>2.真实性认证</h3><p>　<br>　包括身份认证和完整性认证，比如网购时候会验证一下是否你是合法用户，以及发送的信息是否受到篡改；</p>
<h3 id="3-承诺的不可抵赖性"><a href="#3-承诺的不可抵赖性" class="headerlink" title="3.承诺的不可抵赖性"></a>3.承诺的不可抵赖性</h3><p>　<br>防止否认以前的承诺或行为，例如你签收了快递却不承认是你签收的。</p>
<h2 id="密码学的应用"><a href="#密码学的应用" class="headerlink" title="密码学的应用"></a>密码学的应用</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-0846f729851cf05b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</blockquote>
<h2 id="密码与生活息息相关"><a href="#密码与生活息息相关" class="headerlink" title="密码与生活息息相关"></a>密码与生活息息相关</h2><p><img src="http://upload-images.jianshu.io/upload_images/6755082-9fbe23ba6efba9bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</the>]]></content>
      
        <categories>
            
            <category> communication </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客主题使用跟功能添加]]></title>
      <url>/2017/07/07/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%B7%9F%E5%8A%9F%E8%83%BD%E6%B7%BB%E5%8A%A0/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>hexo博客主题使用跟功能添加：</strong><br>没写什么东西，百度上的一篇很长的文章，详细概况了主题的各个部分功能添加与使用，感觉非常全面应该可以帮到大多数需要配置主题的朋友们<br><a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h1 id="新主题使用说明"><a href="#新主题使用说明" class="headerlink" title="新主题使用说明"></a>新主题使用说明</h1><p>次要说的主题基于主题 Hexo-Theme-Yilia 修改而来，在此再次感谢原作者 Litten。修复了一些 bugs，改变了大量的样式，添加了不少特性。对原主题百般折腾后，发觉变动越来越大，索性就发布个新主题了，新主题能稍微凸显出博主个性。各种修改折腾大抵还不错。</p>
<h1 id="新主题效果展示"><a href="#新主题效果展示" class="headerlink" title="新主题效果展示"></a>新主题效果展示</h1><p><img src="http://moxfive.coding.me/yelee/src/feat.background.jpg" alt=""></p>
<h1 id="新主题下载及配置教程"><a href="#新主题下载及配置教程" class="headerlink" title="新主题下载及配置教程"></a>新主题下载及配置教程</h1><p>　　　　　　　　　　　　　　<a href="http://moxfive.coding.me/yelee/" target="_blank" rel="external">点击这里查看</a></p>
]]></content>
      
        <categories>
            
            <category> know </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python代码优化技巧]]></title>
      <url>/2017/07/07/python%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>python代码优化技巧：</strong><br>写个美美的代码还是很重要的，这个将来特别会体现在工作中怎么优化代码呢……<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">



<p>##Python代码性能优化技巧<br>　　代码优化能够让程序运行更快，它是在不改变程序运行结果的情况下使得程序的运行效率更高，根据 80/20 原则，实现程序的重构、优化、扩展以及文档相关的事情通常需要消耗 80% 的工作量。优化通常包含两方面的内容：减小代码的体积，提高代码的运行效率。</p>
<h2 id="改进算法，选择合适的数据结构"><a href="#改进算法，选择合适的数据结构" class="headerlink" title="改进算法，选择合适的数据结构"></a>改进算法，选择合适的数据结构</h2><p>　　一个良好的算法能够对性能起到关键作用，因此性能改进的首要点是对算法的改进。在算法的时间复杂度排序上依次是：</p>
<blockquote>
<p><strong>O(1) -O(lg n) -O(n lg n) -O(n^2) -O(n^3) -O(n^k) -O(k^n) -O(n!)</strong></p>
</blockquote>
<p>　　因此如果能够在时间复杂度上对算法进行一定的改进，对性能的提高不言而喻。但对具体算法的改进不属于本文讨论的范围，读者可以自行参考这方面资料。下面的内容将集中讨论数据结构的选择。</p>
<h2 id="字典-dictionary-与列表-list"><a href="#字典-dictionary-与列表-list" class="headerlink" title="字典 (dictionary) 与列表 (list)"></a>字典 (dictionary) 与列表 (list)</h2><p>　　Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。</p>
<h3 id="清单-1-代码-dict-py"><a href="#清单-1-代码-dict-py" class="headerlink" title="清单 1. 代码 dict.py"></a>清单 1. 代码 dict.py</h3><pre><code>from time import time  
t = time()  
list = [&apos;a&apos;,&apos;b&apos;,&apos;is&apos;,&apos;python&apos;,&apos;jason&apos;,&apos;hello&apos;,&apos;hill&apos;,&apos;with&apos;,&apos;phone&apos;,&apos;test&apos;,  
&apos;dfdf&apos;,&apos;apple&apos;,&apos;pddf&apos;,&apos;ind&apos;,&apos;basic&apos;,&apos;none&apos;,&apos;baecr&apos;,&apos;var&apos;,&apos;bana&apos;,&apos;dd&apos;,&apos;wrd&apos;]  
#list = dict.fromkeys(list,True)  
print list  
filter = []  
for i in range (1000000):  
for find in [&apos;is&apos;,&apos;hat&apos;,&apos;new&apos;,&apos;list&apos;,&apos;old&apos;,&apos;.&apos;]:  
if find not in list:  
filter.append(find)  
print &quot;total run time:&quot; 
print time()-t 
</code></pre><p>　　上述代码运行大概需要 16.09seconds。如果去掉行 #list = dict.fromkeys(list,True) 的注释，将 list 转换为字典之后再运行，时间大约为 8.375 seconds，效率大概提高了一半。因此在需要多数据成员进行频繁的查找或者访问的时候，使用 dict 而不是 list 是一个较好的选择。</p>
<h2 id="集合-set-与列表-list"><a href="#集合-set-与列表-list" class="headerlink" title="集合 (set) 与列表 (list)"></a>集合 (set) 与列表 (list)</h2><p>　　set 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。</p>
<h3 id="清单-2-求-list-的交集："><a href="#清单-2-求-list-的交集：" class="headerlink" title="清单 2. 求 list 的交集："></a>清单 2. 求 list 的交集：</h3><pre><code>from time import time  
t = time()  
lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]  
listb=[2,4,6,9,23]  
intersection=[]  
for i in range (1000000):  
for a in lista:  
for b in listb:  
if a == b:  
intersection.append(a)  
print &quot;total run time:&quot; 
print time()-t 
</code></pre><p>上述程序的运行时间大概为：</p>
<pre><code>total run time:

38.4070000648
</code></pre><h3 id="清单-3-使用-set-求交集"><a href="#清单-3-使用-set-求交集" class="headerlink" title="清单 3. 使用 set 求交集"></a>清单 3. 使用 set 求交集</h3><pre><code>from time import time  
 t = time()  
 lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]  
 listb=[2,4,6,9,23]  
 intersection=[]  
 for i in range (1000000):  
 list(set(lista)&amp;set(listb))  
 print &quot;total run time:&quot; 
 print time()-t 
</code></pre><p>　　改为 set 后程序的运行时间缩减为 8.75，提高了 4 倍多，运行时间大大缩短。读者可以自行使用表 1 其他的操作进行测试。</p>
<h3 id="表-1-set-常见用法"><a href="#表-1-set-常见用法" class="headerlink" title="表 1. set 常见用法"></a>表 1. set 常见用法</h3><p>语法操作说明</p>
<blockquote>
<p>set(list1) | set(list2)             union                    包含 list1 和 list2 所有数据的新集合</p>
<p>set(list1) &amp; set(list2)           intersection          包含 list1 和 list2 中共同元素的新集合</p>
<p>set(list1) – set(list2)           difference             在 list1 中出现但不在 list2 中出现的元素的集合</p>
</blockquote>
<h2 id="对循环的优化"><a href="#对循环的优化" class="headerlink" title="对循环的优化"></a>对循环的优化</h2><p>　　对循环的优化所遵循的原则是尽量减少循环过程中的计算量，有多重循环的尽量将内层的计算提到上一层。 下面通过实例来对比循环优化后所带来的性能的提高。程序清单 4 中，如果不进行循环优化，其大概的运行时间约为 132.375。</p>
<h3 id="清单-4-为进行循环优化前"><a href="#清单-4-为进行循环优化前" class="headerlink" title="清单 4. 为进行循环优化前"></a>清单 4. 为进行循环优化前</h3><pre><code>from time import time  
 t = time()  
 lista = [1,2,3,4,5,6,7,8,9,10]  
 listb =[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.01]  
 for i in range (1000000):  
 for a in range(len(lista)):  
 for b in range(len(listb)):  
 x=lista[a]+listb[b]  
 print &quot;total run time:&quot; 
 print time()-t 
</code></pre><p>　　现在进行如下优化，将长度计算提到循环外，range 用 xrange 代替，同时将第三层的计算 lista[a] 提到循环的第二层。</p>
<h3 id="清单-5-循环优化后"><a href="#清单-5-循环优化后" class="headerlink" title="清单 5. 循环优化后"></a>清单 5. 循环优化后</h3><pre><code>from time import time  
 t = time()  
 lista = [1,2,3,4,5,6,7,8,9,10]  
 listb =[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.01]  
 len1=len(lista)  
 len2=len(listb)  
 for i in xrange (1000000):  
 for a in xrange(len1):  
 temp=lista[a]  
 for b in xrange(len2):  
 x=temp+listb[b]  
 print &quot;total run time:&quot; 
 print time()-t 
</code></pre><p>　　上述优化后的程序其运行时间缩短为 102.171999931。在清单 4 中 lista[a] 被计算的次数为 1000000<em>10</em>10，而在优化后的代码中被计算的次数为 1000000*10，计算次数大幅度缩短，因此性能有所提升。</p>
<h3 id="充分利用-Lazy-if-evaluation-的特性"><a href="#充分利用-Lazy-if-evaluation-的特性" class="headerlink" title="充分利用 Lazy if-evaluation 的特性"></a>充分利用 Lazy if-evaluation 的特性</h3><p>　　python 中条件表达式是 lazy evaluation 的，也就是说如果存在条件表达式 if x and y，在 x 为 false 的情况下 y 表达式的值将不再计算。因此可以利用该特性在一定程度上提高程序效率。</p>
<h3 id="清单-6-利用-Lazy-if-evaluation-的特性"><a href="#清单-6-利用-Lazy-if-evaluation-的特性" class="headerlink" title="清单 6. 利用 Lazy if-evaluation 的特性"></a>清单 6. 利用 Lazy if-evaluation 的特性</h3><pre><code>from time import time  
 t = time()  
 abbreviations = [&apos;cf.&apos;, &apos;e.g.&apos;, &apos;ex.&apos;, &apos;etc.&apos;, &apos;fig.&apos;, &apos;i.e.&apos;, &apos;Mr.&apos;, &apos;vs.&apos;]  
 for i in range (1000000):  
 for w in (&apos;Mr.&apos;, &apos;Hat&apos;, &apos;is&apos;, &apos;chasing&apos;, &apos;the&apos;, &apos;black&apos;, &apos;cat&apos;, &apos;.&apos;):  
 if w in abbreviations:  
 #if w[-1] == &apos;.&apos; and w in abbreviations:  
 pass 
 print &quot;total run time:&quot; 
 print time()-t 
</code></pre><p>　　在未进行优化之前程序的运行时间大概为 8.84，如果使用注释行代替第一个 if，运行的时间大概为 6.17。</p>
<h2 id="字符串的优化"><a href="#字符串的优化" class="headerlink" title="字符串的优化"></a>字符串的优化</h2><p>　　python 中的字符串对象是不可改变的，因此对任何字符串的操作如拼接，修改等都将产生一个新的字符串对象，而不是基于原字符串，因此这种持续的 copy 会在一定程度上影响 python 的性能。对字符串的优化也是改善性能的一个重要的方面，特别是在处理文本较多的情况下。字符串的优化主要集中在以下几个方面：</p>
<p>　　在字符串连接的使用尽量使用 join() 而不是 +：在代码清单 7 中使用 + 进行字符串连接大概需要 0.125 s，而使用 join 缩短为 0.016s。因此在字符的操作上 join 比 + 要快，因此要尽量使用 join 而不是 +。</p>
<h3 id="清单-7-使用-join-而不是-连接字符串"><a href="#清单-7-使用-join-而不是-连接字符串" class="headerlink" title="清单 7. 使用 join 而不是 + 连接字符串"></a>清单 7. 使用 join 而不是 + 连接字符串</h3><pre><code>from time import time  
t = time()  
 s = &quot;&quot;  
 list = [&apos;a&apos;,&apos;b&apos;,&apos;b&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;l&apos;,&apos;m&apos;,&apos;n&apos;]  
 for i in range (10000):  
 for substr in list:  
 s+= substr  
 print &quot;total run time:&quot; 
 print time()-t 
</code></pre><p>同时要避免：</p>
<pre><code>s = &quot;&quot;  
for x in list:  
s += func(x) 
</code></pre><p>而是要使用：</p>
<pre><code>slist = [func(elt) for elt in somelist]
 s = &quot;&quot;.join(slist)
</code></pre><p>　　当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))</p>
<p>　</p>
<blockquote>
<p>对字符进行格式化比直接串联读取要快，因此要使用</p>
</blockquote>
<p><code>out = &quot;%s%s%s%s&quot; % (head, prologue, query, tail)</code><br>而避免</p>
<pre><code>out = &quot;&quot; + head + prologue + query + tail + &quot;&quot; 
</code></pre><p>　　使用列表解析（list comprehension）和生成器表达式（generator expression）</p>
<p>　　列表解析要比在循环中重新构建一个新的 list 更为高效，因此我们可以利用这一特性来提高运行的效率。</p>
<pre><code>from time import time  
 t = time()  
 list = [&apos;a&apos;,&apos;b&apos;,&apos;is&apos;,&apos;python&apos;,&apos;jason&apos;,&apos;hello&apos;,&apos;hill&apos;,&apos;with&apos;,&apos;phone&apos;,&apos;test&apos;,  
 &apos;dfdf&apos;,&apos;apple&apos;,&apos;pddf&apos;,&apos;ind&apos;,&apos;basic&apos;,&apos;none&apos;,&apos;baecr&apos;,&apos;var&apos;,&apos;bana&apos;,&apos;dd&apos;,&apos;wrd&apos;]  
 total=[]  
 for i in range (1000000):  
 for w in list:  
 total.append(w)  
 print &quot;total run time:&quot; 
 print time()-t 
</code></pre><p>使用列表解析：</p>
<pre><code>for i in range (1000000):  
a = [w for w in list] 
</code></pre><p>　　上述代码直接运行大概需要 17s，而改为使用列表解析后 ，运行时间缩短为 9.29s。将近提高了一半。生成器表达式则是在 2.4 中引入的新内容，语法和列表解析类似，但是在大数据量处理时，生成器表达式的优势较为明显，它并不创建一个列表，只是返回一个生成器，因此效率较高。在上述例子上中代码 a = [w for w in list] 修改为 a = (w for w in list)，运行时间进一步减少，缩短约为 2.98s。</p>
</the>]]></content>
      
        <categories>
            
            <category> know </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客主题部分--标签]]></title>
      <url>/2017/07/07/hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E9%83%A8%E5%88%86%E8%AE%BE%E5%AE%9A%E6%B7%BB%E5%8A%A0/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>hexo博客主题部分–标签：</strong><br>标签作为主题里面一个很重要的组成部分，它的文件配置等等，我想这篇文章应该可以帮到你<br><a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>在你的G:\Hexo\source里面新建一个文件夹，命名为tags。新建命令如下：</p>
<pre><code>$ hexo new page &quot;tags&quot;
</code></pre><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：</p>
<pre><code>title： Tagcloud
data： 2017-07-07 12:12:12
type： &quot;tages&quot;
————
</code></pre><p>注意一下如果，如果你的blog启动了多说、畅言这些评论，默认的页面都会出现评论，要是想关闭的话，就把添加comments，把它的值设置为false。设置如下：</p>
<pre><code>title： Tagcloud
data： 2017-07-07 12:12:12
type： &quot;tages&quot;
comment: false
————
</code></pre><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>在主题配置文件中添加配置，如下：</p>
<pre><code>menu:
  #主页: /archives
  所有文章: /archives
  网络安全: /
  密码学: /misc
  计算机语言: /python
  关于我: /about
  tags: /tags
</code></pre><p>要是标签在小目录里就去小目录里面添加配置命令就好了。</p>
<p>看一下我的blog标签效果：<br><img src="http://upload-images.jianshu.io/upload_images/6755082-70bcdbb6c1a915e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
      
        <categories>
            
            <category> know </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python中的汉诺塔递归算法]]></title>
      <url>/2017/07/04/python%E4%B8%AD%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><strong>python中的汉诺塔递归算法</strong><br>第一篇小博客，尽管百度上都有，我还是很认真写的。<br><a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">




<h2 id="什么是汉诺塔"><a href="#什么是汉诺塔" class="headerlink" title="什么是汉诺塔"></a>什么是汉诺塔</h2><p>汉诺塔是将所有盘子（n个）从A柱挪至C柱，中间可以借用B柱，但是最终盘子都得在C柱上，而且需要大盘子在下，小盘子在上</p>
<p><img src="http://images.cnitblog.com/i/585151/201406/241602223308533.gif" alt=""></p>
<h2 id="对应的python代码"><a href="#对应的python代码" class="headerlink" title="对应的python代码"></a>对应的python代码</h2><pre><code>def move(n, a, b, c):
        if n ==1:
             print (a, &apos;--&gt;&apos;, c)
             return
        move(n-1, a, c, b)
        print (a, &apos;--&gt;&apos;, c)
        move(n-1, b, a, c)
    move(n, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;)
</code></pre><p>代码第一行新建一个函数move（n，a，b，c），n代表一共多少个盘子，a、b、c分别代表柱子。下面的if函数说的是，如果就一个盘子，直接把盘子从a移动到c，然后return（返回）；第五行是将n-1个盘子从a经过c移动到b；第六行将a柱的最大盘移动到c柱；第七行是将b柱的盘子经过a移动到c。<br>   递归主要是5、6、7这三行，汉诺塔这个就是按照盘子的多少来不断循环的一个过程。注意不要被参数变化弄糊涂了。</p>
<h2 id="盘子为1、2、3时的结果"><a href="#盘子为1、2、3时的结果" class="headerlink" title="盘子为1、2、3时的结果"></a>盘子为1、2、3时的结果</h2><p>盘子为1个 ：  </p>
<pre><code>A --&gt; C
</code></pre><p> 盘子为2个 ： </p>
<pre><code>A --&gt; B
A --&gt; C
B --&gt; C
</code></pre><p> 盘子为3个：</p>
<pre><code>A --&gt; C
A --&gt; B
C --&gt; B
A --&gt; C
B --&gt; A
B --&gt; C
A --&gt; C
</code></pre></the>]]></content>
      
        <categories>
            
            <category> technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
